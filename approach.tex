\section{Approach}
\label{sec:approach}

This research explores theory presentations and their related constructions in different languages 
(including Agda, Coq, Haskell, Lean, Isabelle, Scala and Idris). In our work theory presentations are 
data 
that can be syntactically manipulated to generate new pieces of knowledge. We first use a data 
description language (DDL) to generate as much information as possible on an abstract level. For 
this 
purpose we use MMT as our abstraction language. We make use of the fact that MMT is platform 
independent to study the minimal logic in which the different generated constructions can be 
defined. 
Afterwards, we start exploring the specific language features of every language of interest, 
determining 
the commonalities and variabilities among them, and how different features would affect the 
generated 
constructions. We then implement the generators to the different target languages. In the sequel 
of 
this section, we discuss the approach in details. 

\subsection{Building Library of Generic algorithms}
\label{sec:library}
As we discussed in Section \ref{sec:intro}, many algebraic constructions can be automatically 
generated by syntactic manipulation of theory presentations. In Section \ref{sec:operations}, we 
discuss some of these constructions and argue that they can be derived without necessarily knowing 
the specific details of the theory in hand, by just identifying its basic components (carrier sets, 
function symbols, ... ). 
To be able to abstract over the language details, we choose to derive our construction in MMT 
language. MMT is a platform independent system built with the idea of minimizing the commitment to a 
specific logic or formal system. This makes it a perfect fit for our idea of abstracting over formal 
systems details. 

Manipulating MMT theories requires dealing with OMDoc terms, the object language of MMT. For 
example, manipulating a theory to generate homomorphism requires:
\begin{itemize}
\item Reading the theory as an OMDoc term, an \verb|OMA| term. An \verb|OMA| term represents the 
application of a term to a given list of terms. 
\item Creating two instances of the theory, by copying the list of declarations and prefixing their 
names. A declaration is represented as an \verb|OML| term, which encodes an MMT declaration with its 
name and optional type, definition and notation. 
\item Creating the preservation axioms for every function symbol. Function symbols are instances of 
\verb|Funtype|. That's how they can be distinguished from sorts and axioms. The axioms are generated 
as \verb|OML| terms. 
\end{itemize}

The result of this step will be a library that contains datatypes describing the constructions to be 
generated and generic algorithms to map between these datatypes using Scala rules, which are 
introduced in \cite{rabe2017recon}


To be able to test our constructions, we started translating MathScheme library into MMT. This 
provides a large enough library for testing. 

\subsection{Exploring Representation Languages}
\label{sec:featuremodel}
One major observation on which we build this work is that different formal languages have different 
ways of presenting mathematical structures that have standard definitions, and embody the same 
information. In Section \ref{sec:intro} we gave an example of representing monoids in different 
formal systems. It can also be seen that the same formal system may represent the theory using 
different language constructs, like in the case of Agda using records and classes. These 
variabilities are mainly due to the different strength of different logics as well as design decisions of 
the language builders as of what features to include in the language. Based on these features, 
some 
of the generated structures may need to be tuned, or may need further information to proceed. In 
this case, we need to determine what information is needed from the user. 

The output of this step is a detailed comparative study of the features of target formal systems 
and 
what constraints this pose on the representation of different constructions. The only tool we are 
aware of for measuring commonalities and variabilities are feature models, which we plan to use in 
our research. 

\subsection{Implementing Generators}
\label{sec:generators}
We now move to the step of actually generating theories in the target languages. 
Our system enables the user to have access to algebraic constructions like homomorphism, term 
languages, simplifiers and others for a specific theory in one of the languages we consider in this 
work. For example, using our library and generator, the user should be able to do something like 
\begin{lstlisting}
BooleanAlgebra := Theory {
    U : type;
    * : (U, U) -> U;
    + : (U, U) -> U;
    --> : (U, U) -> U;
    0 : U;
    1 : U;
    compl : U -> U;
    axiom unipotent_-->_1 : forall x : U. (x --> x) = (1);
    ....
}
generate (termLang, simplify)
\end{lstlisting}
Therefore, by adding some annotation of what algebraic constructions need to be generated, the 
user will have access to these constructions without the need define them. This way, the user can 
run something like 
\begin{lstlisting}
simplify ((x * y) + 1)
\end{lstlisting}
which results in \verb|(x*y)|. This is possible because the definitions of the term language with 
variables and the simplification rules generated by the system. This is similar in spirit to using 
deriving and lenses as we have shown in the examples in Section \ref{sec:related_work}.

\subsection{Timeline}
\begin{itemize}
	\item Translating MathScheme Library: May - Sept 2019
	\item Generating Related Structures in MMT: October - Dec 2019 
	\item Exporting to different languages: Jan - April 2020 
	\item Writing Thesis: April - Sept 2020 
\end{itemize}
